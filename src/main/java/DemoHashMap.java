package main.java;

/*
HashMap https://vertex-academy.com/tutorials/ru/map-v-java-hashmap/
http://java-online.ru/java-map.xhtml
https://devcolibri.com/hashmap-и-hashset-что-это-на-самом-деле/
https://www.examclouds.com/ru/java/java-core-russian/map
http://developer.alexanderklimov.ru/android/java/hashmap.php

Реализация https://habr.com/ru/post/128017/
table — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
При добавлении элемента, последовательность шагов следующая:
1. Генерируется хэш на основе ключа key.hashCode()
2. Определяется позиция в массиве, куда будет помещен элемент indexFor(hash, tableLength)
Помним, что элементы массива это ссылки на списки.
Поскольку позиция в массиве расчитывается с учетом hashCode ключа, то если ключом является объект собственного класса,
т.е. не String, не Integer и т.д., то если у него будет плохая хэш-функция, например, константу постоянно возвращать,
 то HashMap по сути превратится в LinkedList, поскольку все элементы будут вставлять в один и тот же список.
 Соответственно HashMap потеряет все свои преимущества и будет работать медленно как LinkedList.
3. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка.
При совпадении этих параметров, значение элемента списка перезаписывается.
4. Если совпадений не выявлено, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.
Новый элемент добавляется в начало цепочки.
5. Все элементы с null-ключами всегда помещаются в table[0]. При этом если с null-ключом уже есть, то перезаписывается.

Когда массив table[] заполняется до предельного значения, его размер увеличивается вдвое и происходит
перераспределение элементов (пересчитываются индексы с учетом нового размера и перераспределяет по новому
массиву).
Аналогично ArrayList можно задать начальную размерность. По умолчанию создается на 16 элементов.
В отличии от ArrayList можно задать коэффициент загрузки (наполнения). По умолчани 0.75. Это означает, что
при заполнении емкости на 3/4 произойдет ее расширение в 2 раза (всегда в 2, у ArrayList в 1.5).
Таким образом выводы аналогичны ArrayList. Если задать начальную размерность 1, то при добавлении первых элементов
массив будет часто перераспределяться память, а частые перераспределения уменьшаю производительность
Создавать заранее специально очень большим, тоже не имеет смысла, будет выделена лишняя память,
которая реально не будет использована.

Как и у ArrayList при удалении размер массива автоматически не уменьшается. А принудительно невозможно.

Сложность HashMap (по ключу элемента):
        |   HashMap   |  LinkedHashMap  |   TreeMap   |
add     |     O(1)    |       O(1)      |   O(log N)  |
get     |     O(1)    |       O(1)      |   O(log N)  |
remove  |     O(1)    |       O(1)      |   O(log N)  |
contains|     O(1)    |       O(1)      |   O(log N)  |

Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет
элементы и отсутствуют коллизии. Среднее же время работы будет Θ(1 + α), где α — коэффициент загрузки. В самом худшем
случае, время выполнения может составить Θ(n) (все элементы в одном списке);

HashMap - хранит значения в произвольном порядке, но позволяет быстро искать элементы карты. Позволяет задавать ключ
или значение ключевым словом null.
LinkedHashMap - хранит значения в порядке добавления, но работает медленнее и занимает больше места (кроме самого
элемента хранятся еще указатели на следующий и предыдущий элементы списка).
TreeMap - сама сортирует значения по заданному критерию. TreeMap используется либо с Comparable элементами, либо в
связке с Comparator.

Hashtable считается устаревшим. Новый синхронный потокобезопасный вариант это ConcurrentHashMap.
https://www.examclouds.com/ru/java/java-core-russian/legacy-collections
http://javastudy.ru/interview/collections/

ConcurrentHashMap Многопоточный аналог HashMap. Все данные делятся на отдельные сегменты и блокируются только
отдельные сегменты при изменении, что позволяет значительно ускорить работу в многопоточном
режиме. https://itnan.ru/post.php?c=1&p=314386
*/

public class DemoHashMap {
    public static void main(String[] args) {
        //HashMap позволяет удблировать значения, но не ключи

    }
}
